@Service
@RequiredArgsConstructor
@Slf4j
public class FileProcessingService {
    private final FolderService folderService;
    private final FileService fileService;
    private final TransactionalOperator transactionalOperator;
    private final Map<UUID, Sinks.Many<ProgressEvent>> progressSinks = new HashMap<>();

    @Value("${server.folder-path}")
    private String BASE_DIR;

    private int totalErrors;
    private List<String> processedErrorReferences = new ArrayList<>();
    public Mono<FolderDTO> createFolder(UploadRequest request) {
        FolderEntity folder = new FolderEntity(
                request.name(),
                BCEAOStatus.INDEFINI.label, // par défaut statut indéfini
                request.period(),
                0,
                FolderStatus.CREATED.name(),
                LocalDateTime.now(),
                LocalDateTime.now()
        );
        return folderService.getByPeriod(request.period())
                .hasElement()
                .flatMap(exists -> {
                    if(exists){
                        return Mono.error(new DuplicatePeriodFolderException(folder.period()));
                    }else if(getYearInPeriod(request.period()) > LocalDateTime.now().getYear()){
                        return Mono.error(new InvalidYearException(String.valueOf(getYearInPeriod(folder.period()))));
                    }
                    return folderService.save(folder);
                })
                .flatMap(folderSaved -> Mono.fromCallable(() -> {
                    Path path = Paths.get(BASE_DIR + folderSaved.id());
                    Files.createDirectories(path);
                    return folderSaved;
                }).subscribeOn(Schedulers.boundedElastic()))
                .map(folderEntity -> {
                    progressSinks.put(folderEntity.id(), Sinks.many().multicast().onBackpressureBuffer());
                    return new FolderDTO(folderEntity.id(), folderEntity.name(), folderEntity.status());
                })
                .as(transactionalOperator::transactional)
                .onErrorResume(e -> {
                    if (e instanceof BusinessException) {
                        return Mono.error(e); // Ne tente pas de supprimer si c'est un doublon
                    }
                    System.err.println("Erreur lors de la création du dossier : " + e.getMessage());
                    return folderService.delete(folder)
                            .then(Mono.error(e));
                });

    }

    public Flux<ProgressEvent> getProgressUpdates(UUID folderId) {
        return progressSinks.getOrDefault(folderId, Sinks.many().multicast().onBackpressureBuffer())
                .asFlux();
    }

    public Mono<Void> processFiles(UUID folderId, FilePart contractsFile, FilePart errorsFile,
                                   String contractParentTag, String contractChildTag,
                                   String errorParentTag, String errorChildTag) {
        Sinks.Many<ProgressEvent> sink = progressSinks.get(folderId);
        AtomicInteger progress = new AtomicInteger(0);

        return folderService.findById(folderId)
                .switchIfEmpty(Mono.error(new RuntimeException("Folder not found: " + folderId)))
                .timeout(Duration.ofSeconds(300))
                .flatMap(folder -> {
                    // Update folder status
                    FolderEntity updatedFolder = new FolderEntity(
                            folder.id(),
                            folder.name(),
                            folder.bceaoStatus(),
                            folder.period(),
                            0,
                            FolderStatus.PROCESSING.name(),
                            folder.createdAt(),
                            LocalDateTime.now()
                    );
                    return folderService.save(updatedFolder);
                })
                .doOnNext(folder -> {
                    sink.tryEmitNext(new ProgressEvent(folderId, progress.get(), "Démarrage du traitement des fichiers", "PROCESSING"));
                })
                .then(saveFile(folderId, contractsFile, "original", 0))
                .doOnSuccess(file -> {
                    progress.addAndGet(10);
                    sink.tryEmitNext(new ProgressEvent(folderId, progress.get(), "Fichier de contrats XML enregistré", "PROCESSING"));
                })
                .then(saveFile(folderId, errorsFile, "errors", 0))
                .doOnSuccess(file -> {
                    progress.addAndGet(10);
                    sink.tryEmitNext(new ProgressEvent(folderId, progress.get(), "Fichier d'erreurs XML enregistré", "PROCESSING"));
                })
                .then(processXmlFiles(folderId, progress, sink, contractParentTag, contractChildTag, errorParentTag, errorChildTag))
                .onErrorResume(e -> {
                    log.error("Erreur lors du traitement des fichiers XML", e);
                    sink.tryEmitNext(new ProgressEvent(folderId, progress.get(), "Error: " + e.getMessage(), "ERROR"));
                    sink.tryEmitComplete();
                    return updateFolderStatus(folderId, FolderStatus.ERROR.name()).then();
                })
                .then();
    }

    private Mono<FileEntity> saveFile(UUID folderId, FilePart filePart, String type, int version) {
        String fileName = filePart.filename();
        if (version > 0) {
            // Ajouter la version au nom du fichier s'il s'agit d'un fichier versionné
            fileName = getTotalErrors() == version ? "clean_contracts" : "V" + version + "_" + fileName;
        }

        Path targetPath = Paths.get(BASE_DIR + folderId + "/" + fileName);
        FileEntity fileEntity = new FileEntity(
                fileName,
                type,
                version,
                folderId
        );

        return filePart.transferTo(targetPath.toFile())
                .then(fileService.save(fileEntity));
    }

    private Mono<Void> processXmlFiles(UUID folderId, AtomicInteger progress,
                                       Sinks.Many<ProgressEvent> sink,
                                       String contractParentTag, String contractChildTag,
                                       String errorParentTag, String errorChildTag) {
        log.info("Starting XML processing for folder: {}", folderId);

        return fileService.findByFolderIdAndType(folderId, "original")
                .take(1)
                .zipWith(fileService.findByFolderIdAndType(folderId, "errors").take(1))
                .flatMap(tuple -> {
                    FileEntity contractsFileEntity = tuple.getT1();
                    FileEntity errorsFileEntity = tuple.getT2();
                    log.info("Found original file: {} and errors file: {} for folder: {}",
                            contractsFileEntity.name(), errorsFileEntity.name(), folderId);

                    return readContractsAndErrors(folderId, contractsFileEntity, errorsFileEntity)
                            .flatMap(result -> {
                                String originalContractsContent = result.getT1();
                                String errorsContent = result.getT2();
                                log.info("Read contracts and errors content for folder: {}", folderId);

                                // Extract references from error XML with improved logging
                                List<String> errorReferences = extractErrorReferences(errorsContent, errorParentTag, errorChildTag);

                                // Ajouter un log détaillé des références extraites
                                log.info("Extracted error references: {}", errorReferences);

                                // Vérifier les doublons
                                Set<String> uniqueReferences = new HashSet<>(errorReferences);
                                if (uniqueReferences.size() < errorReferences.size()) {
                                    log.warn("Found {} duplicate references in error file",
                                            errorReferences.size() - uniqueReferences.size());
                                }

                                int totalErrors = errorReferences.size();
                                setTotalErrors(totalErrors);

                                // Sauvegarder toutes les références d'erreur dans un fichier pour référence
                                saveErrorReferencesToFile(folderId, errorReferences);

                                log.info("Found {} error references to process for folder: {}", totalErrors, folderId);

                                if (totalErrors == 0) {
                                    sink.tryEmitNext(new ProgressEvent(
                                            folderId,
                                            progress.get(),
                                            "Aucune référence d'erreur trouvée dans le fichier d'erreurs",
                                            FolderStatus.PROCESSING.name()
                                    ));
                                    return finalizeFolderProcessing(folderId, sink, progress);
                                }

                                // Trouver tous les contrats problématiques avec une méthode améliorée
                                return findErrorContractsImproved(originalContractsContent, errorReferences, contractParentTag, contractChildTag)
                                        .flatMap(errorContracts -> {
                                            log.info("Found {} problematic contracts for folder: {}", errorContracts.size(), folderId);

                                            // Vérifier si toutes les références ont été traitées
                                            Set<String> processedRefs = errorContracts.stream()
                                                    .map(ErrorContract::getReference)
                                                    .collect(Collectors.toSet());

                                            Set<String> missingRefs = new HashSet<>(errorReferences);
                                            missingRefs.removeAll(processedRefs);

                                            if (!missingRefs.isEmpty()) {
                                                log.warn("Some error references could not be matched to contracts: {}", missingRefs);
                                                // Sauvegarder les références non traitées
                                                saveUnprocessedReferences(folderId, missingRefs);
                                            }

                                            // Traiter chaque version en se basant sur la version précédente
                                            return Flux.range(0, errorContracts.size())
                                                    .concatMap(i -> {
                                                        ErrorContract errorContract = errorContracts.get(i);
                                                        int versionNumber = i + 1;

                                                        // Si c'est la première version, utiliser l'original, sinon lire la version précédente
                                                        Mono<String> baseContentMono = (i == 0)
                                                                ? Mono.just(originalContractsContent)
                                                                : readVersionContent(folderId, i);

                                                        return baseContentMono.flatMap(baseContent -> {
                                                            log.info("Processing error contract {} of {}: '{}' at position {} for folder: {}",
                                                                    i+1, errorContracts.size(), errorContract.getCode(),
                                                                    errorContract.getPosition(), folderId);

                                                            // Ajouter à la liste des références traitées
                                                            processedErrorReferences.add(errorContract.getReference());

                                                            // Supprimer le contrat problématique
                                                            return removeSpecificContract(
                                                                    folderId,
                                                                    baseContent,
                                                                    errorContract,
                                                                    versionNumber
                                                            ).doOnSuccess(newVersionFile -> {
                                                                int newProgress = 20 + ((i + 1) * 70 / errorContracts.size());
                                                                progress.set(newProgress);
                                                                sink.tryEmitNext(new ProgressEvent(
                                                                        folderId,
                                                                        progress.get(),
                                                                        "Contrat problématique traité " + (i + 1) + " sur " +
                                                                                errorContracts.size() + ": " + errorContract.getCode(),
                                                                        FolderStatus.PROCESSING.name()
                                                                ));
                                                            });
                                                        });
                                                    })
                                                    .then(finalizeFolderProcessing(folderId, sink, progress));
                                        });
                            });
                })
                .then();
    }

    // Méthode améliorée pour extraire les références d'erreur
    private List<String> extractErrorReferences(String xmlContent, String parentTag, String childTag) {
        List<String> references = new ArrayList<>();
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            // Désactiver la validation DTD pour éviter les problèmes de parsing
            factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
            factory.setFeature("http://xml.org/sax/features/namespaces", false);
            factory.setFeature("http://xml.org/sax/features/validation", false);

            DocumentBuilder builder = factory.newDocumentBuilder();

            // Add root element if not present (for fragment processing)
            if (!xmlContent.trim().startsWith("<?xml") && !xmlContent.trim().startsWith("<")) {
                xmlContent = "<root>" + xmlContent + "</root>";
            }

            // Parse XML content
            Document document = builder.parse(new org.xml.sax.InputSource(new StringReader(xmlContent)));

            // Get all parent tag elements
            NodeList parentElements = document.getElementsByTagName(parentTag);
            log.info("Found {} {} elements in error file", parentElements.getLength(), parentTag);

            // Extract reference values from child tags
            for (int i = 0; i < parentElements.getLength(); i++) {
                Element parentElement = (Element) parentElements.item(i);
                NodeList childElements = parentElement.getElementsByTagName(childTag);

                if (childElements.getLength() > 0) {
                    String referenceValue = childElements.item(0).getTextContent().trim();
                    if (!referenceValue.isEmpty()) {
                        // Traitement amélioré pour extraire uniquement la position numérique
                        String cleanedReference = referenceValue;
                        // Pour supprimer "LIGNE 2;COLONNE " qui est présent sur les fichiers XML
                        if (referenceValue.contains("LIGNE 2;COLONNE ")) {
                            cleanedReference = referenceValue.replace("LIGNE 2;COLONNE ", "");
                        } else if (referenceValue.contains("LIGNE") || referenceValue.contains("COLONNE")) {
                            // Extraire seulement les chiffres si le format est différent
                            cleanedReference = referenceValue.replaceAll("[^0-9]", "");
                        }

                        references.add(cleanedReference);
                        log.info("Extracted reference: {} -> {}", referenceValue, cleanedReference);
                    }
                }
            }

            // Trier les références par ordre numérique pour un traitement plus cohérent
            references.sort((a, b) -> {
                try {
                    return Integer.parseInt(a) - Integer.parseInt(b);
                } catch (NumberFormatException e) {
                    return a.compareTo(b);
                }
            });

        } catch (Exception e) {
            log.error("Error parsing XML for error references", e);
        }
        return references;
    }
    // Classe pour stocker les informations des contrats problématiques
    private static class ErrorContract {
        private final String reference;
        private final String code;
        private final int startPosition;
        private final int endPosition;

        public ErrorContract(String reference, String code, int startPosition, int endPosition) {
            this.reference = reference;
            this.code = code;
            this.startPosition = startPosition;
            this.endPosition = endPosition;
        }

        public String getReference() {
            return reference;
        }

        public String getCode() {
            return code;
        }

        public int getPosition() {
            return startPosition;
        }

        public int getStartPosition() {
            return startPosition;
        }

        public int getEndPosition() {
            return endPosition;
        }
    }

    // Méthode pour trouver tous les contrats problématiques en une seule passe
    private Mono<List<ErrorContract>> findErrorContracts(String xmlContent, List<String> errorReferences,
                                                         String contractParentTag, String contractChildTag) {
        return Mono.fromCallable(() -> {
            List<ErrorContract> errorContracts = new ArrayList<>();

            try {
                // Balises à rechercher
                String openTag = "<" + contractParentTag;
                String closeTag = "</" + contractParentTag + ">";
                String codeOpenTag = "<" + contractChildTag + ">";
                String codeCloseTag = "</" + contractChildTag + ">";

                // Trouver toutes les balises contractParentTag dans le document
                int searchPos = 0;
                int contractIndex = 0;

                while (searchPos < xmlContent.length()) {
                    int startTagPos = xmlContent.indexOf(openTag, searchPos);
                    if (startTagPos == -1) break;

                    int endTagPos = xmlContent.indexOf(closeTag, startTagPos);
                    if (endTagPos == -1) break;

                    endTagPos += closeTag.length();
                    String contractContent = xmlContent.substring(startTagPos, endTagPos);

                    // Extraire le code du contrat
                    String contractCode = null;
                    int codeStart = contractContent.indexOf(codeOpenTag);
                    if (codeStart != -1) {
                        int codeValueStart = codeStart + codeOpenTag.length();
                        int codeValueEnd = contractContent.indexOf(codeCloseTag, codeValueStart);
                        if (codeValueEnd != -1) {
                            contractCode = contractContent.substring(codeValueStart, codeValueEnd);
                        }
                    }

                    // Vérifier si ce contrat correspond à une référence d'erreur
                    for (String reference : errorReferences) {
                        try {
                            int position = Integer.parseInt(reference);

                            // Si la position est dans ce contrat ou si c'est le contrat juste après la position
                            if ((position >= startTagPos && position < endTagPos) ||
                                    (contractIndex > 0 && position >= searchPos && position < startTagPos)) {
                                errorContracts.add(new ErrorContract(reference, contractCode, startTagPos, endTagPos));
                                break;
                            }
                        } catch (NumberFormatException e) {
                            log.warn("Invalid position reference: {}", reference);
                        }
                    }

                    searchPos = endTagPos;
                    contractIndex++;
                }

                log.info("Found {} error contracts from {} error references", errorContracts.size(), errorReferences.size());
                return errorContracts;

            } catch (Exception e) {
                log.error("Error finding problematic contracts", e);
                throw new RuntimeException("Error finding problematic contracts: " + e.getMessage(), e);
            }
        }).subscribeOn(Schedulers.boundedElastic());
    }

    // Méthode pour supprimer un contrat spécifique
    private Mono<FileEntity> removeSpecificContract(UUID folderId, String xmlContent,
                                                    ErrorContract errorContract, int version) {
        return Mono.fromCallable(() -> {
            try {
                // Supprimer le contrat spécifique
                String updatedContent = xmlContent.substring(0, errorContract.getStartPosition()) +
                        xmlContent.substring(errorContract.getEndPosition());

                // Sauvegarder la nouvelle version
                String fileName = "V" + version + "_contracts.xml";
                Path targetPath = Paths.get(BASE_DIR + folderId + "/" + fileName);
                Files.createDirectories(targetPath.getParent());
                Files.writeString(targetPath, updatedContent);

                // Sauvegarder l'information du contrat supprimé
                saveRemovedContractId(folderId, errorContract.getReference(), errorContract.getCode(), version);

                // Créer l'entité fichier
                FileEntity versionedFile = new FileEntity(
                        fileName,
                        "versioning",
                        version,
                        folderId
                );

                return versionedFile;
            } catch (Exception e) {
                log.error("Error generating version file", e);
                throw new RuntimeException("Error generating version file: " + e.getMessage(), e);
            }
        }).flatMap(fileService::save);
    }

    // Nouvelle méthode pour lire le contenu de la version précédente
    private Mono<String> readVersionContent(UUID folderId, int previousVersion) {
        String fileName = "V" + previousVersion + "_contracts.xml";
        Path filePath = Paths.get(BASE_DIR + folderId + "/" + fileName);

        return Mono.fromCallable(() ->
                Files.readString(filePath, StandardCharsets.UTF_8)
        ).subscribeOn(Schedulers.boundedElastic());
    }
    private Mono<Tuple2<String, String>> readContractsAndErrors(UUID folderId, FileEntity contractsFileEntity, FileEntity errorsFileEntity) {
        Path contractsPath = Paths.get(BASE_DIR + folderId + "/" + contractsFileEntity.name());
        Path errorsPath = Paths.get(BASE_DIR + folderId + "/" + errorsFileEntity.name());

        return Mono.fromCallable(() -> {
            String contracts = Files.readString(contractsPath, StandardCharsets.UTF_8);
            String errors = Files.readString(errorsPath, StandardCharsets.UTF_8);
            return Tuples.of(contracts, errors);
        });
    }

    // Nouvelle méthode pour trouver les contrats problématiques de manière plus robuste
    private Mono<List<ErrorContract>> findErrorContractsImproved(String xmlContent, List<String> errorReferences,
                                                                 String contractParentTag, String contractChildTag) {
        return Mono.fromCallable(() -> {
            List<ErrorContract> errorContracts = new ArrayList<>();
            Map<String, Boolean> referencesProcessed = new HashMap<>();

            // Initialiser toutes les références comme non traitées
            for (String ref : errorReferences) {
                referencesProcessed.put(ref, false);
            }

            try {
                // Balises à rechercher
                String openTag = "<" + contractParentTag;
                String closeTag = "</" + contractParentTag + ">";
                String codeOpenTag = "<" + contractChildTag + ">";
                String codeCloseTag = "</" + contractChildTag + ">";

                // Trouver toutes les balises contractParentTag dans le document
                List<Triple<Integer, Integer, String>> contracts = new ArrayList<>();
                int searchPos = 0;

                while (searchPos < xmlContent.length()) {
                    int startTagPos = xmlContent.indexOf(openTag, searchPos);
                    if (startTagPos == -1) break;

                    int endTagPos = xmlContent.indexOf(closeTag, startTagPos);
                    if (endTagPos == -1) break;

                    endTagPos += closeTag.length();
                    String contractContent = xmlContent.substring(startTagPos, endTagPos);

                    // Extraire le code du contrat
                    String contractCode = null;
                    int codeStart = contractContent.indexOf(codeOpenTag);
                    if (codeStart != -1) {
                        int codeValueStart = codeStart + codeOpenTag.length();
                        int codeValueEnd = contractContent.indexOf(codeCloseTag, codeValueStart);
                        if (codeValueEnd != -1) {
                            contractCode = contractContent.substring(codeValueStart, codeValueEnd);
                        }
                    }

                    contracts.add(Triple.of(startTagPos, endTagPos, contractCode));
                    searchPos = endTagPos;
                }

                // Pour chaque référence d'erreur, trouver le contrat correspondant
                for (String reference : errorReferences) {
                    try {
                        int position = Integer.parseInt(reference);
                        boolean foundContract = false;

                        // D'abord chercher si la position est directement dans un contrat
                        for (Triple<Integer, Integer, String> contract : contracts) {
                            int start = contract.getLeft();
                            int end = contract.getMiddle();
                            String code = contract.getRight();

                            if (position >= start && position < end) {
                                errorContracts.add(new ErrorContract(reference, code, start, end));
                                referencesProcessed.put(reference, true);
                                foundContract = true;
                                break;
                            }
                        }

                        // Si on n'a pas trouvé, chercher le contrat le plus proche après cette position
                        if (!foundContract) {
                            Triple<Integer, Integer, String> closestContract = null;
                            int minDistance = Integer.MAX_VALUE;

                            for (Triple<Integer, Integer, String> contract : contracts) {
                                int start = contract.getLeft();

                                if (start > position && (start - position) < minDistance) {
                                    minDistance = start - position;
                                    closestContract = contract;
                                }
                            }

                            if (closestContract != null) {
                                errorContracts.add(new ErrorContract(
                                        reference,
                                        closestContract.getRight(),
                                        closestContract.getLeft(),
                                        closestContract.getMiddle()
                                ));
                                referencesProcessed.put(reference, true);
                            } else {
                                log.warn("No appropriate contract found for reference {}", reference);
                            }
                        }
                    } catch (NumberFormatException e) {
                        log.warn("Invalid position reference: {}", reference);
                    }
                }

                // Vérifier les références non traitées
                for (Map.Entry<String, Boolean> entry : referencesProcessed.entrySet()) {
                    if (!entry.getValue()) {
                        log.warn("Reference not processed: {}", entry.getKey());
                    }
                }

                // Trier les contrats d'erreur par position pour un traitement cohérent
                errorContracts.sort(Comparator.comparingInt(ErrorContract::getStartPosition));

                log.info("Found {} error contracts from {} error references",
                        errorContracts.size(), errorReferences.size());

                return errorContracts;

            } catch (Exception e) {
                log.error("Error finding problematic contracts", e);
                throw new RuntimeException("Error finding problematic contracts: " + e.getMessage(), e);
            }
        }).subscribeOn(Schedulers.boundedElastic());
    }
    // Méthode pour sauvegarder toutes les références d'erreur dans un fichier
    private void saveErrorReferencesToFile(UUID folderId, List<String> errorReferences) {
        try {
            Path filePath = Paths.get(BASE_DIR + folderId + "/all_error_references.txt");
            Files.createDirectories(filePath.getParent());

            List<String> lines = new ArrayList<>();
            lines.add("Total error references found: " + errorReferences.size());
            lines.add("References (sorted):");
            for (int i = 0; i < errorReferences.size(); i++) {
                lines.add((i+1) + ". " + errorReferences.get(i));
            }

            Files.write(filePath, lines);
            log.info("Saved all {} error references to file for folder {}", errorReferences.size(), folderId);
        } catch (IOException e) {
            log.error("Failed to save error references to file", e);
        }
    }

    // Méthode pour sauvegarder les références qui n'ont pas pu être traitées
    private void saveUnprocessedReferences(UUID folderId, Set<String> missingRefs) {
        try {
            Path filePath = Paths.get(BASE_DIR + folderId + "/unprocessed_references.txt");
            Files.createDirectories(filePath.getParent());

            List<String> lines = new ArrayList<>();
            lines.add("Total unprocessed references: " + missingRefs.size());
            lines.add("Unprocessed references:");

            int i = 1;
            for (String ref : missingRefs) {
                lines.add(i + ". " + ref);
                i++;
            }

            Files.write(filePath, lines);
            log.info("Saved {} unprocessed references to file for folder {}", missingRefs.size(), folderId);
        } catch (IOException e) {
            log.error("Failed to save unprocessed references to file", e);
        }
    }

    private Mono<Void> finalizeFolderProcessing(UUID folderId, Sinks.Many<ProgressEvent> sink, AtomicInteger progress) {
        log.info("Starting finalizeFolderProcessing for folder: {}", folderId);

        return Mono.fromCallable(() -> {
                    // Créer un rapport détaillé incluant toutes les informations sur le traitement
                    createDetailedReport(folderId);

                    // Create a file entity for removed_contracts.txt
                    Path filePath = Paths.get(BASE_DIR + folderId + "/removed_contracts.txt");
                    log.info("Checking for removed_contracts.txt at path: {}", filePath);

                    FileEntity resultFile = null;
                    if (Files.exists(filePath)) {
                        log.info("Found existing removed_contracts.txt for folder {}", folderId);
                        resultFile = new FileEntity(
                                "removed_contracts.txt",
                                "result",
                                0,
                                folderId
                        );
                    } else {
                        log.info("Creating new removed_contracts.txt for folder {}", folderId);
                        // Create an empty result file if it doesn't exist
                        Files.createDirectories(filePath.getParent());
                        Files.writeString(filePath, "No contracts were removed");

                        resultFile = new FileEntity(
                                "removed_contracts.txt",
                                "result",
                                0,
                                folderId
                        );
                    }

                    // Créer aussi une entité pour le rapport détaillé
                    FileEntity reportFile = new FileEntity(
                            "processing_report.txt",
                            "report",
                            0,
                            folderId
                    );

                    log.info("Created FileEntity for removed_contracts.txt: {}", resultFile);
                    return Tuples.of(resultFile, reportFile);
                })
                .flatMap(tuple -> {
                    FileEntity resultFile = tuple.getT1();
                    FileEntity reportFile = tuple.getT2();

                    log.info("Saving FileEntity for removed_contracts.txt in folder: {}", folderId);
                    return fileService.save(resultFile)
                            .then(fileService.save(reportFile))
                            .doOnSuccess(saved -> log.info("Successfully saved result files"))
                            .doOnError(err -> log.error("Error saving result files: {}", err.getMessage()));
                })
                .flatMap(savedFile -> {
                    log.info("Result files saved, now updating folder status to COMPLETED for folder: {}", folderId);
                    return folderService.findById(folderId)
                            .doOnSuccess(folder -> {
                                if (folder != null) {
                                    log.info("Found folder with ID: {}", folder.id());
                                } else {
                                    log.warn("Folder not found with ID: {}", folderId);
                                }
                            })
                            .flatMap(folder -> {
                                FolderEntity folderToSave = new FolderEntity(
                                        folder.id(),
                                        folder.name(),
                                        folder.bceaoStatus(),
                                        folder.period(),
                                        getTotalErrors(), // Mettre à jour le nombre d'erreurs
                                        FolderStatus.COMPLETED.name(),
                                        folder.createdAt(),
                                        LocalDateTime.now()
                                );
                                log.info("About to save updated folder: {} with status COMPLETED", folder.id());
                                return folderService.save(folderToSave)
                                        .doOnSuccess(saved -> log.info("Successfully updated folder status to COMPLETED for folder: {}", saved.id()))
                                        .doOnError(err -> log.error("Error updating folder status: {}", err.getMessage()));
                            });
                })
                .doOnSuccess(folder -> {
                    log.info("Folder processing completed successfully for folder: {}", folderId);
                    // Emit final progress event
                    progress.set(100);
                    try {
                        sink.tryEmitNext(new ProgressEvent(
                                folderId,
                                100,
                                "Traitement terminé avec succès (" + getTotalErrors() + " erreurs traitées)",
                                FolderStatus.COMPLETED.name()
                        ));
                        log.info("Emitted final progress event for folder: {}", folderId);
                        sink.tryEmitComplete();
                        log.info("Completed progress sink for folder: {}", folderId);
                    } catch (Exception e) {
                        log.error("Error emitting final progress event: {}", e.getMessage());
                    }
                })
                .doOnError(error -> {
                    log.error("Error during finalization for folder {}: {}", folderId, error.getMessage(), error);
                    try {
                        sink.tryEmitNext(new ProgressEvent(
                                folderId,
                                progress.get(),
                                "Error finalizing: " + error.getMessage(),
                                FolderStatus.ERROR.name()
                        ));
                        sink.tryEmitComplete();
                    } catch (Exception e) {
                        log.error("Error emitting error progress event: {}", e.getMessage());
                    }
                })
                .then()
                .doOnTerminate(() -> {
                    log.info("Finalization process terminated for folder: {}", folderId);
                    // Réinitialiser les références traitées pour le prochain traitement
                    processedErrorReferences.clear();
                });
    }

    // Méthode pour créer un rapport détaillé du traitement
    private void createDetailedReport(UUID folderId) {
        try {
            Path filePath = Paths.get(BASE_DIR + folderId + "/processing_report.txt");
            Files.createDirectories(filePath.getParent());

            List<String> lines = new ArrayList<>();
            lines.add("=== RAPPORT DE TRAITEMENT ===");
            lines.add("Dossier ID: " + folderId);
            lines.add("Date de traitement: " + LocalDateTime.now());
            lines.add("Nombre total d'erreurs: " + getTotalErrors());
            lines.add("Nombre de références traitées: " + processedErrorReferences.size());

            if (processedErrorReferences.size() < getTotalErrors()) {
                lines.add("ATTENTION: " + (getTotalErrors() - processedErrorReferences.size()) +
                        " références n'ont pas été traitées.");
            }

            lines.add("\n=== LISTE DES RÉFÉRENCES TRAITÉES ===");
            for (int i = 0; i < processedErrorReferences.size(); i++) {
                lines.add((i+1) + ". " + processedErrorReferences.get(i));
            }

            Files.write(filePath, lines);
            log.info("Created detailed processing report for folder {}", folderId);
        } catch (IOException e) {
            log.error("Failed to create detailed processing report", e);
        }
    }
    // Méthode modifiée pour accepter une liste de références à supprimer
    private Mono<FileEntity> generateNewContractVersion(UUID folderId, String contractsContent,
                                                        List<String> references, int version,
                                                        String contractParentTag, String contractChildTag) {
        return Mono.fromCallable(() -> {
            try {
                String updatedContent = contractsContent;
                List<String> removedCodes = new ArrayList<>();

                // Traiter chaque référence à supprimer
                for (String reference : references) {
                    Tuple2<String, String> result = removeContractByReference(
                            updatedContent, reference, contractParentTag, contractChildTag);

                    updatedContent = result.getT1();
                    String removedContractCode = result.getT2();

                    if (removedContractCode == null || removedContractCode.isEmpty()) {
                        log.warn("No contract found for reference: {}", reference);
                        removedContractCode = "not-found-" + reference;
                    }

                    removedCodes.add(removedContractCode);
                }

                // Save the updated content
                String fileName = "V" + version + "_contracts.xml";
                Path targetPath = Paths.get(BASE_DIR + folderId + "/" + fileName);
                Files.createDirectories(targetPath.getParent());
                Files.writeString(targetPath, updatedContent);

                // Save all removed contract IDs for this version
                for (int i = 0; i < references.size(); i++) {
                    saveRemovedContractId(folderId, references.get(i), removedCodes.get(i), version);
                }

                // Create file entity
                FileEntity versionedFile = new FileEntity(
                        fileName,
                        "versioning",
                        version,
                        folderId
                );

                return versionedFile;
            } catch (Exception e) {
                log.error("Error generating version file", e);
                throw new RuntimeException("Error generating version file: " + e.getMessage(), e);
            }
        }).flatMap(fileService::save);
    }

    private Tuple2<String, String> removeContractByReference(String xmlContent, String reference,
                                                             String contractParentTag, String contractChildTag) {
        try {
            // Convertir reference en position numérique
            int position = Integer.parseInt(reference);

            // Vérifier si la position est valide
            if (position < 0 || position >= xmlContent.length()) {
                log.warn("Position {} hors limites du document XML", position);
                return Tuples.of(xmlContent, null);
            }

            // Balises à rechercher
            String openTag = "<" + contractParentTag;
            String closeTag = "</" + contractParentTag + ">";

            // Liste de toutes les balises contractParentTag
            List<Pair<Integer, Integer>> contractTags = new ArrayList<>();

            // Trouver toutes les balises contractParentTag dans le document
            int searchPos = 0;
            while (searchPos < xmlContent.length()) {
                int startTagPos = xmlContent.indexOf(openTag, searchPos);
                if (startTagPos == -1) break;

                int endTagPos = xmlContent.indexOf(closeTag, startTagPos);
                if (endTagPos == -1) break;

                endTagPos += closeTag.length();
                contractTags.add(Pair.of(startTagPos, endTagPos));
                searchPos = endTagPos;
            }

            // Trouver la balise qui contient notre position
            for (Pair<Integer, Integer> tagPair : contractTags) {
                int start = tagPair.getFirst();
                int end = tagPair.getSecond();

                // Si la position est dans cette balise
                if (position >= start && position < end) {
                    // Extraire le contenu du contrat à supprimer
                    String contractContent = xmlContent.substring(start, end);

                    // Extraire le code du contrat si disponible
                    String contractCode = null;
                    String codeOpenTag = "<" + contractChildTag + ">";
                    String codeCloseTag = "</" + contractChildTag + ">";
                    int codeStart = contractContent.indexOf(codeOpenTag);
                    if (codeStart != -1) {
                        int codeValueStart = codeStart + codeOpenTag.length();
                        int codeValueEnd = contractContent.indexOf(codeCloseTag, codeValueStart);
                        if (codeValueEnd != -1) {
                            contractCode = contractContent.substring(codeValueStart, codeValueEnd);
                        }
                    }

                    // Créer le nouveau contenu XML sans le contrat
                    String updatedContent = xmlContent.substring(0, start) +
                            xmlContent.substring(end);

                    log.info("Supprimé le contrat à la position {} avec code: {}", position, contractCode);
                    return Tuples.of(updatedContent, contractCode);
                }
            }

            // Si on arrive ici, aucun contrat contenant la position n'a été trouvé
            // Dans ce cas, chercher le contrat suivant
            for (Pair<Integer, Integer> tagPair : contractTags) {
                int start = tagPair.getFirst();

                // Si cette balise commence après notre position
                if (start > position) {
                    int end = tagPair.getSecond();
                    String contractContent = xmlContent.substring(start, end);

                    // Extraire le code du contrat si disponible
                    String contractCode = null;
                    String codeOpenTag = "<" + contractChildTag + ">";
                    String codeCloseTag = "</" + contractChildTag + ">";
                    int codeStart = contractContent.indexOf(codeOpenTag);
                    if (codeStart != -1) {
                        int codeValueStart = codeStart + codeOpenTag.length();
                        int codeValueEnd = contractContent.indexOf(codeCloseTag, codeValueStart);
                        if (codeValueEnd != -1) {
                            contractCode = contractContent.substring(codeValueStart, codeValueEnd);
                        }
                    }

                    // Créer le nouveau contenu XML sans le contrat
                    String updatedContent = xmlContent.substring(0, start) +
                            xmlContent.substring(end);

                    log.info("Aucun contrat trouvé à la position {}, supprimé le contrat suivant avec code: {}",
                            position, contractCode);
                    return Tuples.of(updatedContent, contractCode);
                }
            }

            log.warn("Aucun contrat trouvé à ou après la position {}", position);
            return Tuples.of(xmlContent, null);

        } catch (NumberFormatException e) {
            log.error("La référence doit être un nombre valide", e);
            return Tuples.of(xmlContent, null);
        } catch (Exception e) {
            log.error("Erreur lors de la suppression du contrat par référence", e);
            return Tuples.of(xmlContent, null);
        }
    }

    private void saveRemovedContractId(UUID folderId, String reference, String contractCode, int version) {
        try {
            Path filePath = Paths.get(BASE_DIR + folderId + "/removed_contracts.txt");
            Files.createDirectories(filePath.getParent());

            // Créer l'entrée sans ajouter de saut de ligne supplémentaire
            String entry = String.format("Version %d: Removed contract with reference %s and code %s",
                    version, reference, contractCode);

            if (Files.exists(filePath)) {
                // Lire toutes les lignes du fichier
                List<String> lines = Files.readAllLines(filePath);

                // Filtrer les lignes pour exclure celle avec la même version
                List<String> updatedLines = lines.stream()
                        .filter(line -> !line.startsWith("Version " + version + ":"))
                        .collect(Collectors.toList());

                // Ajouter la nouvelle entrée
                updatedLines.add(entry);

                // Réécrire le fichier avec les lignes mises à jour, en joignant avec un saut de ligne
                Files.write(filePath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);
            } else {
                // Si le fichier n'existe pas, simplement écrire la nouvelle entrée
                Files.write(filePath, Collections.singletonList(entry));
            }

            log.info("Contract reference {} and code {} saved to removed_contracts.txt for version {}",
                    reference, contractCode, version);
        } catch (IOException e) {
            log.error("Failed to save removed contract information", e);
        }
    }
   
    private Mono<FolderEntity> updateFolderStatus(UUID folderId, String status) {
        return folderService.findById(folderId)
                .map(folder -> new FolderEntity(
                        folder.id(),
                        folder.name(),
                        folder.bceaoStatus(),
                        folder.period(),
                        status.equals(FolderStatus.ERROR.name()) ? 0 : null,
                        status,
                        folder.createdAt(),
                        LocalDateTime.now()
                ))
                .flatMap(folderService::save);
    }

    public int getTotalErrors() {
        return totalErrors;
    }

    public void setTotalErrors(int totalErrors) {
        this.totalErrors = totalErrors;
    }

    public int getYearInPeriod(String period){
        String[] yearChar=period.split("-");
        return Integer.parseInt(yearChar[1]);
    }
}