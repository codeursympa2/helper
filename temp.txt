// Nouvelle méthode pour générer une version spécifique à la demande
public Mono<String> generateVersionedContractFile(UUID folderId, int version) {
    log.info("Generating version {} of contract file for folder: {}", version, folderId);
    
    return fileService.findByFolderIdAndType(folderId, "original")
            .take(1)
            .switchIfEmpty(Mono.error(new IllegalStateException("Original file not found")))
            .zipWith(fileService.findByFolderIdAndType(folderId, "errors").take(1)
                    .switchIfEmpty(Mono.error(new IllegalStateException("Errors file not found"))))
            .flatMap(tuple -> {
                FileEntity contractsFileEntity = tuple.getT1();
                FileEntity errorsFileEntity = tuple.getT2();
                
                return readContractsAndErrors(folderId, contractsFileEntity, errorsFileEntity)
                        .flatMap(result -> {
                            String originalContractsContent = result.getT1();
                            String errorsContent = result.getT2();
                            
                            // Extraire les références d'erreur
                            List<String> errorReferences = extractErrorReferences(errorsContent, "LIGNE", "COLONNE");
                            
                            if (errorReferences.isEmpty()) {
                                return Mono.just(originalContractsContent);
                            }
                            
                            if (version <= 0 || version > errorReferences.size()) {
                                return Mono.error(new IllegalArgumentException(
                                        "Version invalide. Doit être entre 1 et " + errorReferences.size()));
                            }
                            
                            // Identifier les codes des contrats à supprimer
                            return findContractCodesToRemove(originalContractsContent, errorReferences, "CONTRAT", "CODE")
                                    .flatMap(contractCodesToRemove -> {
                                        // Nous allons supprimer seulement les N premiers contrats selon la version demandée
                                        List<String> contractsToRemove = contractCodesToRemove.subList(0, version);
                                        
                                        // Convertir explicitement en Mono<String> pour éviter le problème de type
                                        return Mono.<String>fromCallable(() -> {
                                            String resultContent = originalContractsContent;
                                            
                                            // Supprimer un par un les contrats dans l'ordre
                                            for (int i = 0; i < contractsToRemove.size(); i++) {
                                                String contractCode = contractsToRemove.get(i);
                                                resultContent = removeContractFromContent(
                                                        resultContent, contractCode, "CONTRAT", "CODE");
                                                log.info("Removed contract {} for version {}", contractCode, version);
                                            }
                                            
                                            return resultContent;
                                        }).subscribeOn(Schedulers.boundedElastic());
                                    });
                        });
            });
}